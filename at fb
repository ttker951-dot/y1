-- 持续检测关卡出口传送器（ExitTeleporter专用）
-- 放置位置：StarterPlayerScripts (LocalScript)

local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")
local Workspace = game:GetService("Workspace")

-- 本地玩家核心引用
local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local humanoid = character:WaitForChild("Humanoid")

-- 核心配置（只检测ExitTeleporter）
local CONFIG = {
    TargetTeleporterName = "ExitTeleporter",  -- 固定检测ExitTeleporter
    CheckInterval = 1,                        -- 检测间隔（秒）
    TweenTime = 0.8,                          -- 平滑传送时间（秒）
    EasingStyle = Enum.EasingStyle.Quad,      -- 缓动样式
    EasingDirection = Enum.EasingDirection.Out,-- 缓动方向
    DisableMovement = true,                   -- 传送时禁用移动
    DetectionRadius = 1000,                   -- 检测半径（增大以便检测远处关卡）
    CooldownAfterTeleport = 3                 -- 传送后的冷却时间（秒）
}

-- 状态控制
local isTeleporting = false
local isDetecting = true
local lastTeleportTime = 0
local lastTeleportedLevel = 0

-- 更新角色引用（角色重生时）
local function updateCharacterReferences()
    character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
    humanoid = character:WaitForChild("Humanoid")
    print("[传送检测] 角色已刷新，重新初始化引用")
    
    -- 重置传送状态
    isTeleporting = false
end

-- 获取所有关卡的ExitTeleporter信息
local function getAllExitTeleporters()
    local teleporters = {}
    
    -- 检查Map.Dungeon结构
    local map = Workspace:FindFirstChild("Map")
    if not map then return teleporters end
    
    local dungeonFolder = map:FindFirstChild("Dungeon")
    if not dungeonFolder then return teleporters end
    
    -- 遍历所有关卡文件夹
    for _, levelFolder in pairs(dungeonFolder:GetChildren()) do
        -- 检查是否为数字命名的关卡文件夹
        local levelNumber = tonumber(levelFolder.Name)
        if levelNumber then
            -- 只检测ExitTeleporter
            local teleporter = levelFolder:FindFirstChild(CONFIG.TargetTeleporterName)
            if teleporter then
                local rootPart = teleporter:FindFirstChild("Root")
                if rootPart then
                    table.insert(teleporters, {
                        level = levelNumber,
                        teleporter = teleporter,
                        rootPart = rootPart,
                        position = rootPart.Position
                    })
                end
            end
        end
    end
    
    -- 按关卡数字排序
    table.sort(teleporters, function(a, b)
        return a.level < b.level
    end)
    
    return teleporters
end

-- 获取当前关卡数（通过查找最近的ExitTeleporter）
local function getCurrentLevel()
    local playerPosition = humanoidRootPart.Position
    local allTeleporters = getAllExitTeleporters()
    local closestLevel = nil
    local minDistance = math.huge
    
    for _, teleporterInfo in ipairs(allTeleporters) do
        local distance = (playerPosition - teleporterInfo.position).Magnitude
        if distance < minDistance and distance < CONFIG.DetectionRadius then
            minDistance = distance
            closestLevel = teleporterInfo.level
        end
    end
    
    return closestLevel, minDistance
end

-- 平滑传送函数
local function teleportToTarget(rootPart, level)
    if isTeleporting then return end
    
    -- 检查冷却时间
    local currentTime = tick()
    if currentTime - lastTeleportTime < CONFIG.CooldownAfterTeleport then
        return
    end
    
    -- 不再检查距离是否太近
    isTeleporting = true
    lastTeleportTime = currentTime
    lastTeleportedLevel = level

    print(string.format("[传送检测] 检测到第%d关的ExitTeleporter，开始平滑传送...", level))

    -- 禁用移动
    if CONFIG.DisableMovement then
        humanoid.WalkSpeed = 0
        humanoid.JumpPower = 0
    end

    -- 创建平滑传送Tween
    local tweenInfo = TweenInfo.new(
        CONFIG.TweenTime,
        CONFIG.EasingStyle,
        CONFIG.EasingDirection
    )
    local teleportGoal = { CFrame = rootPart.CFrame }
    local tween = TweenService:Create(humanoidRootPart, tweenInfo, teleportGoal)
    
    -- 执行传送
    tween:Play()

    -- 传送完成处理
    tween.Completed:Connect(function()
        -- 恢复移动
        if CONFIG.DisableMovement then
            humanoid.WalkSpeed = 16
            humanoid.JumpPower = 50
        end
        
        print(string.format("[传送检测] 已成功传送至第%d关的ExitTeleporter！", level))
        
        -- 短暂延迟后恢复检测
        task.wait(0.5)
        isTeleporting = false
    end)
end

-- 主要检测循环
local function mainDetectionLoop()
    print("[传送检测] 开始持续检测ExitTeleporter...")
    print("[传送检测] 目标传送器: " .. CONFIG.TargetTeleporterName)
    print("[传送检测] 模式: 持续检测直到游戏结束")

    while isDetecting do
        -- 等待下一个检测周期
        task.wait(CONFIG.CheckInterval)
        
        -- 检查游戏是否还在运行
        if not game:IsLoaded() or not localPlayer then
            break
        end
        
        -- 角色死亡/重生时重新初始化
        if not character or not character:IsDescendantOf(Workspace) or humanoid.Health <= 0 then
            updateCharacterReferences()
            continue
        end
        
        -- 如果正在传送中，跳过检测
        if isTeleporting then
            continue
        end
        
        -- 获取当前关卡和所有ExitTeleporter信息
        local currentLevel, currentDistance = getCurrentLevel()
        local allTeleporters = getAllExitTeleporters()
        
        if currentLevel then
            print(string.format("[传送检测] 当前在第%d关附近，距离: %.1f", currentLevel, currentDistance))
            
            -- 查找当前关卡的ExitTeleporter
            for _, teleporterInfo in ipairs(allTeleporters) do
                if teleporterInfo.level == currentLevel then
                    -- 不再检查距离，直接传送
                    teleportToTarget(teleporterInfo.rootPart, currentLevel)
                    break
                end
            end
        else
            -- 如果没有检测到当前关卡，尝试检测所有关卡的ExitTeleporter
            for _, teleporterInfo in ipairs(allTeleporters) do
                local distance = (humanoidRootPart.Position - teleporterInfo.position).Magnitude
                if distance < CONFIG.DetectionRadius then
                    print(string.format("[传送检测] 检测到第%d关ExitTeleporter，距离: %.1f", teleporterInfo.level, distance))
                    teleportToTarget(teleporterInfo.rootPart, teleporterInfo.level)
                    break
                end
            end
        end
    end
    
    print("[传送检测] 检测循环已结束")
end

-- 绑定角色重生事件
localPlayer.CharacterAdded:Connect(updateCharacterReferences)

-- 处理玩家离开游戏
localPlayer:GetPropertyChangedSignal("Parent"):Connect(function()
    if not localPlayer.Parent then
        isDetecting = false
        print("[传送检测] 玩家离开游戏，停止检测")
    end
end)

-- 手动控制指令
localPlayer.Chatted:Connect(function(message)
    if message == "/stopdetect" then
        isDetecting = false
        print("[传送检测] 已停止循环检测")
    elseif message == "/startdetect" then
        if not isDetecting then
            isDetecting = true
            task.spawn(mainDetectionLoop)
            print("[传送检测] 已重启循环检测")
        end
    elseif message == "/checklevel" then
        local currentLevel, distance = getCurrentLevel()
        if currentLevel then
            print(string.format("[传送检测] 当前关卡: %d, 距离ExitTeleporter: %.1f", currentLevel, distance))
        else
            print("[传送检测] 无法确定当前关卡")
        end
    elseif message:match("^/goto (%d+)$") then
        local targetLevel = tonumber(message:match("^/goto (%d+)$"))
        if targetLevel then
            local allTeleporters = getAllExitTeleporters()
            local found = false
            
            for _, teleporterInfo in ipairs(allTeleporters) do
                if teleporterInfo.level == targetLevel then
                    teleportToTarget(teleporterInfo.rootPart, targetLevel)
                    found = true
                    break
                end
            end
            
            if not found then
                print(string.format("[传送检测] 未找到第%d关的ExitTeleporter", targetLevel))
            end
        end
    elseif message == "/listlevels" then
        local allTeleporters = getAllExitTeleporters()
        if #allTeleporters > 0 then
            print("[传送检测] 找到的关卡ExitTeleporter:")
            for _, teleporterInfo in ipairs(allTeleporters) do
                local distance = (humanoidRootPart.Position - teleporterInfo.position).Magnitude
                print(string.format("  - 第%d关: 位置 %s, 距离 %.1f", 
                    teleporterInfo.level, 
                    tostring(teleporterInfo.position:ToVector2()),
                    distance))
            end
        else
            print("[传送检测] 未找到任何关卡的ExitTeleporter")
        end
    elseif message == "/status" then
        print("[传送检测] 状态信息:")
        print("  - 检测状态: " .. (isDetecting and "运行中" or "已停止"))
        print("  - 传送状态: " .. (isTeleporting and "传送中" or "就绪"))
        print("  - 最后传送关卡: " .. lastTeleportedLevel)
        print("  - 冷却时间剩余: " .. math.max(0, CONFIG.CooldownAfterTeleport - (tick() - lastTeleportTime)) .. "秒")
        print("  - 当前目标: " .. CONFIG.TargetTeleporterName)
    elseif message == "/config" then
        print("[传送检测] 当前配置:")
        print("  - 目标传送器: " .. CONFIG.TargetTeleporterName)
        print("  - 检测间隔: " .. CONFIG.CheckInterval .. "秒")
        print("  - 传送时间: " .. CONFIG.TweenTime .. "秒")
        print("  - 检测半径: " .. CONFIG.DetectionRadius .. "单位")
        print("  - 传送冷却: " .. CONFIG.CooldownAfterTeleport .. "秒")
    end
end)

-- 启动脚本
updateCharacterReferences()

-- 启动主循环（在单独的协程中运行，避免阻塞）
task.spawn(function()
    mainDetectionLoop()
end)

print("[传送检测] 脚本已启动，将持续检测所有关卡的ExitTeleporter直到游戏结束")
